package gov.nasa.jpf.regression.analysis;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import jpf_diff.Control;
import jpf_diff.Data;
import jpf_diff.Dependency;

import org.apache.bcel.generic.AASTORE;
import org.apache.bcel.classfile.LocalVariable;
import org.apache.bcel.classfile.LocalVariableTable;
import org.apache.bcel.generic.ArithmeticInstruction;
import org.apache.bcel.generic.ArrayInstruction;
import org.apache.bcel.generic.BASTORE;
import org.apache.bcel.generic.CASTORE;
import org.apache.bcel.generic.DASTORE;
import org.apache.bcel.generic.DCMPG;
import org.apache.bcel.generic.DCMPL;
import org.apache.bcel.generic.FASTORE;
import org.apache.bcel.generic.FCMPG;
import org.apache.bcel.generic.FCMPL;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.GETSTATIC;
import org.apache.bcel.generic.IASTORE;
import org.apache.bcel.generic.IINC;
import org.apache.bcel.generic.IfInstruction;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.LASTORE;
import org.apache.bcel.generic.LCMP;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.bcel.generic.PUTSTATIC;
import org.apache.bcel.generic.SASTORE;
import org.apache.bcel.generic.StoreInstruction;
import org.apache.bcel.verifier.structurals.InstructionContext;

import edu.byu.cs.analysis.InstructionNode;
import edu.byu.cs.analysis.NodeInfo;
import edu.byu.cs.analysis.VariableInfo;
import edu.byu.cs.analysis.dependency.ControlDependency;
import edu.byu.cs.analysis.dependency.ControlNode;
import edu.byu.cs.analysis.dependency.PostDominanceSet;
import edu.byu.cs.analysis.dependency.PostDominanceTree;
import edu.byu.cs.analysis.instruction.m_FieldInstruction;
import edu.byu.cs.analysis.instruction.m_PUTFIELD;
import edu.byu.cs.analysis.instruction.m_PUTSTATIC;
import edu.byu.cs.trace.AbstractMethodInfo;
import gov.nasa.jpf.regression.cfg.CFG;


public class AnalyzeIntraProceduralDiff {

	@SuppressWarnings("unused")
	private static boolean debug = false;

	public Map<Integer, Set<Dependency> > depend;
	
	AbstractMethodInfo absMethodInfo;
	CFG cfg;
	MethodGen mg;
	//Each conditional branch bytecode position maps to a unique
	//integer, the data structure contains the mapping
	HashMap<Integer, Integer> condToIntMap;

	//Variable names map to the set of conditional branches that use
	//the corresponding variable when evaluating hte branch predicate
	HashMap<String, ArrayList<Integer>> varNameToCondBranchPosMap;

	//A map that contains for each conditional branch position the
	//set of Write(Store instruction, getfield, putfield) instructions
	// that are control dependent on the conditional branch (either
	// true or false).
	public HashMap<Integer, ArrayList<Integer>> branchToDependentWriteInsMap;

	public HashMap<Integer, ArrayList<Integer>> branchToDependentSecondaryInsMap;


	//A map that contains position of instruction of bytecode positions
	//that use the value generated by other (one or more) __UNKNOWN__
	//instructions identified by their bytecode positions
	HashMap<Integer, ArrayList<Integer>> opToOtherOp;

	//A map that contains positions of instruction of bytecode positions
	//that use the values of variables identified by their names
	HashMap<Integer, ArrayList<String>> opToVarNames;

	HashMap<Integer, ArrayList<Integer>> opToRetValOfCallSites;

	HashMap<String, ArrayList<Integer>> varNamesToWriteIns;

	HashMap<Integer, ArrayList<Integer>> readVarPosToWriteVarPosMap;

	ArrayList<String> exploredVarNames = new ArrayList<String>();
	Set<Integer> exploredVarPoses = new HashSet<Integer>();

	SCC scc;

	ControlDependency cd;
	DistanceMatrix dm;
	Set<Integer> globalTrackCond;
	protected Set<Integer> globalTrackWrite;
	Set<Integer> trackCond;

	Set<Integer> dependentTrack = new HashSet<Integer>();
	Set<Integer> canbeDropped = new HashSet<Integer>();

	protected Set<Integer> visited = new HashSet<Integer>();

	private HashMap<Integer, InstructionContext> insContext;
	
	protected boolean preciseHeap = false;
	
	/*
	 * setPreciseHeap: boolean -> void
	 * given a boolean value, this method will set the value of this
	 * preciseHeap variable to that boolean value.
	 */
	public void setPreciseHeap(boolean precise) {
		
		this.preciseHeap = precise;
	}
	
	public HashMap<String, ArrayList<Integer>> 
					getVariablesUsedInConditionalBranchesMap() {
		return this.varNameToCondBranchPosMap;
	}
	
	public HashMap<String, ArrayList<Integer>>
				getVariablesWrittenToInStoreInstructionsMap() {
		return this.varNamesToWriteIns;
	}
	
	public HashMap<Integer, ArrayList<String>>
				getVariablesUsedInStoreInstructionsMap() {
		return this.opToVarNames;
	}
	
	public AnalyzeIntraProceduralDiff(AbstractMethodInfo absMethodInfo, CFG cfg,
				MethodGen mg) {
		this.absMethodInfo = absMethodInfo;
		this.cfg = cfg;
		this.mg = mg;
		condToIntMap = new HashMap<Integer, Integer>();
		varNameToCondBranchPosMap = new HashMap<String, ArrayList<Integer>>();
		branchToDependentWriteInsMap = new HashMap<Integer, ArrayList<Integer>>();
		branchToDependentSecondaryInsMap = new HashMap<Integer, ArrayList<Integer>>();
		opToOtherOp = new HashMap<Integer, ArrayList<Integer>>();
		opToVarNames = new HashMap<Integer, ArrayList<String>>();
		opToRetValOfCallSites = new HashMap<Integer, ArrayList<Integer>>();
		
		depend = new HashMap<Integer, Set<Dependency>>();
		
		// TODO: This name seems misleading and inconsistent, consider fixing
		// perhaps change to something like: varNameToWritePosnMap to make it
		// more similar to varNameToCondBranchPosMap.
		varNamesToWriteIns = new HashMap<String, ArrayList<Integer>>();
		
		readVarPosToWriteVarPosMap = new HashMap<Integer,
										ArrayList<Integer>>();

		if(cfg != null) {
			scc = new SCC(cfg);
			scc.stronglyConnectedComponents();
		}
		
		PostDominanceSet pds = new PostDominanceSet(absMethodInfo.getbcelCFG(), mg);
		pds.buildSet();
		PostDominanceTree pdt = new PostDominanceTree(pds);
		pdt.buildTree();

		cd = new ControlDependency(pdt,pds);
		//cd.computeControlDependency();
		globalTrackCond = new HashSet<Integer>();
		globalTrackWrite = new HashSet<Integer>();
		trackCond = new HashSet<Integer>();

		insContext = absMethodInfo.getInstructionContexts();

	}

	public CFG getCFG() {
		return cfg;
	}



	public Set<Integer> getGlobalTrackCondition(){
		return this.globalTrackCond;
	}

	public Set<Integer> getGlobalTrackWrite(){
		return this.globalTrackWrite;
	}

	public void analyzeConditionalBranchStatements () {
		 HashMap<Integer, String> conditionalExp = absMethodInfo.
		 											getConditionalExpression();
		 Iterator<Integer> condItr = conditionalExp.keySet().iterator();
		 int counter = 0;
		 while(condItr.hasNext()) {
			 Integer condPos = condItr.next();
			 condToIntMap.put(condPos, counter);
			 counter++;
			 generateVarsAffectCondBranches(condPos);
		 }
		 dm = new DistanceMatrix(counter);
		 cd.computeControlDependency();
		 Set<ControlNode> controlD = cd.getControlNodes();
		 Iterator<ControlNode> cNodeItr = controlD.iterator();

		 while(cNodeItr.hasNext()) {
			 ControlNode controlNode = cNodeItr.next();
			 Integer pos = controlNode.getControlNodePos();
			 assert (condToIntMap.containsKey(pos));

			 Integer posToCounter = condToIntMap.get(pos);
			 ArrayList<Integer> dependent = controlNode.getControlDependentNodes();
			 ArrayList<Integer> dependentWriteIns = new ArrayList<Integer>();
			 ArrayList<Integer> dependentSecondaryIns = new ArrayList<Integer>();

			 for(int dIndex = 0; dIndex < dependent.size(); dIndex++) {
				 Integer dPos = dependent.get(dIndex);

				 genControlDependentWriteIns(dPos, dependentWriteIns);
				 genControlDependentSecondaryIns(dPos, dependentSecondaryIns);

				 if(!condToIntMap.containsKey(dPos)) continue;
				 Integer dPosToCounter = condToIntMap.get(dPos);
				 if (dm == null || dPosToCounter == null || posToCounter == null) {
					continue;
				}
				 dm.setValue(dPosToCounter, posToCounter, 1);
			 }
			 if(branchToDependentWriteInsMap.containsKey(pos)) {
				 branchToDependentWriteInsMap.get(pos).addAll(dependentWriteIns);
			 } else {
				 branchToDependentWriteInsMap.put(pos, dependentWriteIns);
			 }

			 for(int secondIndex = 0; secondIndex < dependentSecondaryIns.size(); secondIndex++) {
				 Integer secondPos = dependentSecondaryIns.get(secondIndex);
				 ArrayList<Integer> controllingBranches;
				 if(branchToDependentSecondaryInsMap.containsKey(secondPos)) {
					 controllingBranches = branchToDependentSecondaryInsMap.get(secondPos);
				 } else{
					 controllingBranches = new ArrayList<Integer>();
				 }
				 branchToDependentSecondaryInsMap.put(secondPos, controllingBranches);
			 }

			 if(branchToDependentSecondaryInsMap.containsKey(pos)) {
				 branchToDependentSecondaryInsMap.get(pos).addAll(dependentSecondaryIns);
			 } else {
				 branchToDependentSecondaryInsMap.put(pos, dependentSecondaryIns);
			 }
		 }
		 dm.computeShortestPathEstimates();
		 //System.out.println("Testing" + branchToDependentWriteInsMap.toString());
		 // dm.printMatrix();

	}

	private void genControlDependentWriteIns(Integer dPos,
												 ArrayList<Integer> dependentWriteIns) {
		 InstructionContext ic = insContext.get(dPos);
		 if (ic == null) {
			return;
		}
		 InstructionHandle inhl = ic.getInstruction();
		 Instruction insn = inhl.getInstruction();
		 if(isWriteInstruction(insn)) {
			 dependentWriteIns.add(dPos);
		 }
	}

	private void genControlDependentSecondaryIns(Integer dPos,
			ArrayList<Integer> dependentSecondaryIns) {

		InstructionContext ic = insContext.get(dPos);
		if (ic == null) {
			return;
		}
		Instruction insn = ic.getInstruction().getInstruction();
		if(!isWriteInstruction(insn)) {
			dependentSecondaryIns.add(dPos);
		}
	}

	protected boolean isWriteInstruction(Instruction insn) {
		if(insn instanceof StoreInstruction || insn instanceof IINC ||
				insn instanceof PUTFIELD || insn instanceof PUTSTATIC ||
				insn instanceof AASTORE || insn instanceof BASTORE ||
			    insn instanceof CASTORE || insn instanceof DASTORE ||
				insn instanceof FASTORE || insn instanceof IASTORE ||
				insn instanceof LASTORE || insn instanceof SASTORE)
			return true;
		return false;
	}

	/**
	 * 应用规则1，如果ACN中有一个节点ni，且存在一个条件节点nj，其中nj控制依赖于ni，那么将nj加入到ACN中
	 * @param conditionalBr
	 * @param genTransitiveCondDep
	 * @return
	 */
	public Set<Integer> generateSetOfAffectCondBranches(Set<Integer> conditionalBr,
			boolean genTransitiveCondDep) {
		Set<Integer> currTrackedCond = new HashSet<Integer>();
		HashMap<Integer, String> conditionalExp =
									absMethodInfo.getConditionalExpression();
		Iterator<Integer> condItr = conditionalExp.keySet().iterator();
		while(condItr.hasNext()) {
			 Integer condLoc = condItr.next();
			 //first check whether the condLoc is modified
			 if(conditionalBr.contains(condLoc)) {
				 trackCond.add(condLoc);
				 currTrackedCond.add(condLoc);
				 //如果是初始的modified condLoc
				 if (!depend.containsKey(condLoc)) {
					Dependency dependency = new Dependency(condLoc, -1);
					Set<Dependency> dependencies = new HashSet<>();
					dependencies.add(dependency);
					depend.put(condLoc, dependencies);
				}
			 } else { // check if it is control dependent on a modified conditional branch
				// TODO: this is bad bad form.... change it
				 if(genTransitiveCondDep) {
					 generateSetOfControlDependentCondStatements(condLoc,
							 conditionalBr, currTrackedCond);
				 }
			 }
		}
		return currTrackedCond;
	}

	private void generateSetOfControlDependentCondStatements(Integer condLoc,
			Set<Integer> conditionalBr, Set<Integer> currTrackedCond) {
		 Integer condPosCounter = condToIntMap.get(condLoc);
		 Iterator<Integer> modItr = conditionalBr.iterator();
			 while(modItr.hasNext()) {
				Integer modPos = modItr.next();
				if(!condToIntMap.containsKey(modPos)) continue;
				Integer modPosCounter = condToIntMap.get(modPos);
				if(dm.getValue(condPosCounter, modPosCounter) <
						Integer.MAX_VALUE &&
						dm.getValue(condPosCounter, modPosCounter) != 0) {
					trackCond.add(condLoc);
					currTrackedCond.add(condLoc);
					//添加对应的控制依赖关系
					if (!depend.containsKey(condLoc)) {
						Dependency dependency = new Control(condLoc, modPos);
						Set<Dependency> dependencies = new HashSet<>();
						dependencies.add(dependency);
						depend.put(condLoc, dependencies);
					}
					else {
						Dependency dependency = new Control(condLoc, modPos);
						depend.get(condLoc).add(dependency);
					}
					break;
				}
			 }
	}
	
	/**
	 * constructQualifiedFieldReference: Integer -> String
	 * given the position of a GET field instruction, this method will use the
	 * absMethodInfo to look at the controlPathAnalysis and predecessors so
	 * that it can construct the series of field references that make up the
	 * field reference at the specified position.
	 * For instance, if given the position 27 for the field 'a' of object e1,
	 * then this method will construct the string 'heap.Example02.e1' because
	 * that is the field reference for getting at field a. 
	 * 
	 * @param position
	 * 			the position of a GET field instruction of interest
	 * @return String
	 * 			the resulting qualified Field Reference.
	 */
	public String constructQualifiedFieldReference(Integer position) {
		
		String fieldRef = "";
		
		InstructionContext ic =
				this.absMethodInfo.getInstructionContexts().get(position);
		
		if(!(ic.getInstruction().getInstruction() instanceof GETFIELD)) {
			return "";
		}
		
		// look at the predecessor to get its name
		ArrayList<Integer> predPositions =
				this.absMethodInfo.getPredecessors().get(position);
		
		Integer predPosition = predPositions.get(0);
		String predName = this.getUnqualifiedVariableName(predPosition);
		String qualifier = this.constructQualifiedFieldReference(predPosition);
		
		if(!qualifier.equals("")) {
			fieldRef = qualifier + "." + predName;
		}
		else {
			fieldRef = this.getFieldReferenceString(ic, false);
		}
		
		return fieldRef;
	}
	
	/**
	 * constructQualifiedFieldName: Integer -> String
	 * given the position of a GET field instruction, this method will use the
	 * use the getUnqualifiedFieldVariableName and the
	 * constructQualifiedFieldReference methods which will be concatenated
	 * together to produce the qualified field name which will be returned.
	 * 
	 * @param position
	 * 			the position of the GET field instruction of instance
	 * @return String
	 * 			the resulting qualified field name for the given GET position
	 */
	public String constructQualifiedFieldName(Integer position) {
		
		String qualifiedFieldName = "";
		
		String fieldName = this.getUnqualifiedVariableName(position);
		String fieldRef = this.constructQualifiedFieldReference(position);
		
		qualifiedFieldName = fieldRef + "." + fieldName;
		
		return qualifiedFieldName;
	}

	public String getFullyQualifiedFieldBeingWritten(Integer putPos) {
		HashMap<Integer, InstructionNode> controlInfo = absMethodInfo.
				 						getControlPathAnalysisInfo();
		String finalPutName = "";	
		InstructionNode in = controlInfo.get(putPos);	
		m_PUTFIELD putField = (m_PUTFIELD) in.getInst();
		
		VariableInfo vi = putField.getNameAndType();
		int objSize = vi.getObjSize();
		for(int i = objSize - 1; i >=0; i--) {
			finalPutName = finalPutName.concat(getPart(vi.getVariableNameAtIndex(i).toString(), 
									vi.getVariableTypeAtIndex(i).toString()) +".");
		}
		
		finalPutName = finalPutName.concat(getPart(vi.getVariableName().toString(),
							vi.getVariableType().toString())+".");
		
		finalPutName = finalPutName.concat(putField.getFieldName());
	
		return finalPutName;
	}
	
	private String getPart(String name, String type) {
		if(name.equals("this")) return type;
		else return name;
	}
	
	/**
	 * generateVarsAffectCondBranches - given the Integer position of
	 * a conditional branch, this method goes through the instructions
	 * that make up the condition and updates the mapping of variable
	 * names to conditional branch positions.
	 * @param condPos
	 * 			The bytecode position of a conditional branch
	 */
	public void generateVarsAffectCondBranches (Integer condPos){
		 HashMap<Integer, ArrayList<Integer>> preds = absMethodInfo.getPredecessors();
		 HashMap<Integer, InstructionNode> controlInfo = absMethodInfo.
		 												 getControlPathAnalysisInfo();

		 ArrayList<Integer> predLocs = preds.get(condPos);
		 InstructionContext controlNode = insContext.get(condPos);
		 IfInstruction ifInsn = (IfInstruction)controlNode.getInstruction().
		 															getInstruction();
		 int stackNum = ifInsn.consumeStack(mg.getConstantPool());
		 for(int predIndex = 0; predIndex < predLocs.size(); predIndex++) {
			 Integer predPos = predLocs.get(predIndex);
			 if(controlInfo.containsKey(predPos)) {
				 InstructionNode in = controlInfo.get(predPos);
				 NodeInfo node = in.getNodeInfo();

				 ArrayList<VariableInfo> stackVars = node.getStackFrame();
				 int bound = stackVars.size() - stackNum;
				 for(int sIndex = (stackVars.size() - 1);
				 					sIndex >= 0 && sIndex >= bound;
				 					sIndex--) {
					 VariableInfo vi = stackVars.get(sIndex);

					 if(vi.getVariableType().
							 toString().equals("__CONSTANT_VAL__")) {
						 continue;
					 }
					 else if (vi.getVariableName().toString().equals
							 ("__UNKNOWN__")) {
						 ArrayList<String> varNames = 
								getVarsUsedInWriteAndArthInsn(vi.getPositionOfVariable());
						 for(int varIndex =0; varIndex < varNames.size(); varIndex++) {
							 updateVariableAffectingCondBranch(varNames.get(varIndex),
									 condPos);
						 }
					 }
					 // the conditional branch maybe using a return value of
					 // a call site, even in the intraprocedural analysis
					 // where the call site is ignored the return value will be around
					 else if (vi.getVariableName().equals("RETURN_ELEMENT")) {
						 ArrayList<Integer> otherPos;
							if(opToRetValOfCallSites.containsKey(condPos)) {
								otherPos = opToRetValOfCallSites.get(condPos);
							} else {
								otherPos = new ArrayList<Integer>();
							}
							otherPos.add(vi.getPositionOfVariable());
							opToRetValOfCallSites.put(condPos, otherPos);
					 } else {
						 InstructionContext viContext = insContext.get
						 							(vi.getPositionOfVariable());
						 Instruction viInsn = viContext.getInstruction().
						 							getInstruction();
						 String varName = vi.getVariableName().toString();
						 if(viInsn instanceof GETFIELD || viInsn instanceof GETSTATIC) {
//							 String fullName = this.getFieldReferenceString(viContext, false);
//							 //varName = vi.getVariableType().toString() + "." + varName;
//							 varName = fullName.concat("." + varName);
							 // FIXME: Pretty sure this doesn't account for instructions that
							 // are GETSTATIC because constructQualifiedFieldName() probably
							 // doesn't work for GETSTATIC instructions.
							 varName =
									 this.constructQualifiedFieldName(vi.getPositionOfVariable());
						 }
						 updateVariableAffectingCondBranch(varName, condPos);
					 }

				 }
			 }
		 }

	}
	
	/**
	 * FIXME: It should be noted that this method doesn't work for all cases
	 * and as such it should probably be removed. Instead, the method
	 * AnalyzeInterProceduralDiff.stringTogetherFieldReferences should be used.
	 * TODO: Change this to Type rather than Name!
	 * getQualifiedVariableName: Integer -> String
	 * given the position of a FieldInstruction, this method will use the data
	 * in the absMethodInfo to look at the VariableInfo for that position
	 * which will have the name of the variable and allow us to use the
	 * getFieldReferenceString to get the qualifier.
	 * @param position
	 * 			the position of the instruction that we are interested in
	 * @param String
	 * 			the qualified variable name at the given position
	 */
	protected String getQualifiedVariableName(Integer position) {
		
		HashMap<Integer, InstructionNode> controlPathAnalysis =
				this.absMethodInfo.getControlPathAnalysisInfo();
		
		InstructionContext ic =
				this.absMethodInfo.getInstructionContexts().get(position);
		
		// Start by getting the InstructionNode for the current getInstruction
		InstructionNode currInsnNode = controlPathAnalysis.get(position);
		ArrayList<VariableInfo> stackFrame = currInsnNode.getNodeInfo().getStackFrame();
		
		String qualifiedVarName = "";
		
		VariableInfo vi = stackFrame.get(0);
		String varName = vi.getVariableName().toString();
		String qualifier = this.getFieldReferenceString(ic, false);
		
		qualifiedVarName = qualifier + "." + varName;
		
		//System.out.println("################# " + vi.toString());
		
		return qualifiedVarName;
	}
	
	/**
	 * getUnqualifiedVariableName: Integer -> String
	 * given the position of a FieldInstruction, this method will use the data
	 * in the absMethodInfo to look at the VariableInfo for that position
	 * which will have the name of the variable, this name will be returned.
	 * 
	 * @param position
	 * 			the position of the FieldInstruction of interest
	 * @return String
	 * 			the name of the field being referenced (unqualified)
	 */
	protected String getUnqualifiedVariableName(Integer position) {
		
		HashMap<Integer, InstructionNode> controlPathAnalysis =
				this.absMethodInfo.getControlPathAnalysisInfo();
		
		InstructionContext ic =
				this.absMethodInfo.getInstructionContexts().get(position);
		
		int toPop = ic.getInstruction().getInstruction().
								consumeStack(mg.getConstantPool());
		String variableName = "";
		
		InstructionNode insn = controlPathAnalysis.get(position);
		ArrayList<VariableInfo> stackFrame =
						insn.getNodeInfo().getStackFrame();
		int startIndex = stackFrame.size() - 1;

		for(int varIndex = startIndex;
			(varIndex >=0 && varIndex > (startIndex - toPop));
			varIndex--) {
			
			VariableInfo vi = stackFrame.get(varIndex);
			if(variableName != "") {
				variableName += "." + vi.getVariableName();
			}
			else {
				variableName = (String)vi.getVariableName();
			}
		}
		
		return variableName;
	}
	
	/**
	 * getVarsUsedInWriteAndArthInsn: ArrayList<String> Integer -> void
	 * ...
	 * @param pos
	 * 
	 * @return TODO
	 */
	public ArrayList<String> getVarsUsedInWriteAndArthInsn(Integer pos) {
		ArrayList<String> variableNames = new ArrayList<String>(); 
		visited.clear();
		getVarsAssociatedWithIns(variableNames, pos);
		return variableNames;
	}

	/**
	 * getVarsAssociatedWithIns: ArrayList<String> Integer -> void
	 * given a String ArrayList (which is most likely empty on the initial
	 * invocation) and an Integer which represents the position of the
	 * instruction that is being investigated, this method will use the
	 * previously built opToVarNames and opToOtherOp data structures to
	 * determine the names of the variables that are involved with the 
	 * specified instruction position,
	 * adding each to the given String ArrayList. As long as the
	 * invoker has access to the String ArrayList, it will have access to the
	 * resulting set of variable names.
	 * 
	 * @param varNames
	 * 			the arraylist of variables that is being built
	 * @param pos
	 * 			the position of the instruction being investigated
	 */
	protected void getVarsAssociatedWithIns(ArrayList<String> varNames, Integer pos ) {
		if(opToVarNames.containsKey(pos)) {
			varNames.addAll(opToVarNames.get(pos));
		}
		if(opToOtherOp.containsKey(pos)) {
			ArrayList<Integer> newPos = opToOtherOp.get(pos);
			for (int pIndex = 0; pIndex < newPos.size(); pIndex++) {
				if(visited.contains(newPos.get(pIndex))) continue;
				visited.add(newPos.get(pIndex));
				getVarsAssociatedWithIns(varNames, newPos.get(pIndex));
			}
		}
	}

	/**
	 * updateVariableAffectingCondBranch: String Integer -> void
	 * given the name of a variable and an Integer representing the position
	 * of a conditional instruction, this method will update the
	 * varNameToCondBranchPosMap by mapping the variable name to the set of
	 * conditional branch position that it affects. If a mapping does not
	 * already exist for the given variable name, then put a new one in the
	 * map, otherwise just add to the existing one.
	 * 
	 * @param varName
	 * @param condPos
	 */
	private void updateVariableAffectingCondBranch(String varName, Integer condPos) {
		 
		// if the varName isn't already mapped, then create a new entry
		 if(!this.varNameToCondBranchPosMap.containsKey(varName)) {
			 this.varNameToCondBranchPosMap.put(varName, new ArrayList<Integer>());
		 }
		 this.varNameToCondBranchPosMap.get(varName).add(condPos);
	}

	/**
	 * genWriteInsUsingModifiedWriteVals:
	 * 	Set<Integer> HashMap<String, ArrayList<Integer>> -> none
	 * given a set of write instruction positions that have been modified, this
	 * method will go through those write instructions getting the name of the
	 * variable being written to and then mapping it to the list of write
	 * instructions that it affects.
	 * 
	 * @param writePos
	 * 			the set of write instruction positions that were modified
	 * @param writeInsToVarsMap
	 * 			the mapping of var names to instruction positions that is to
	 * 			be populated by this method
	 */
	public void genWriteInsUsingModifiedWriteVals (Set<Integer> writePos,
						HashMap<String, ArrayList<Integer>> writeInsToVarsMap) {
		exploredVarNames.clear();
		exploredVarPoses.clear();
		Iterator<Integer> writeItr = writePos.iterator();

		ArrayList<String> tmpVarNames = new ArrayList<String>();
		ArrayList<Integer> tmpVarPositions = new ArrayList<Integer>();


		while(writeItr.hasNext()) {
			Integer wPos = writeItr.next();
			assert (insContext.containsKey(wPos));
			InstructionContext ic = insContext.get(wPos);
			Instruction insn = ic.getInstruction().getInstruction();
			String varName = getWriteVariableName(insn, ic);
			if(varName != null) {

				// Maps varName to the set of instruction positions it is at.
				addWriteInsVarToInsnPositions(varName, ic,
						writeInsToVarsMap);
				tmpVarNames.add(varName);
				tmpVarPositions.add(ic.getInstruction().getPosition());
			}
		}

		for(int varIndex = 0; varIndex < tmpVarNames.size(); varIndex++) {
			exploreWriteInsn(tmpVarNames.get(varIndex),
							tmpVarPositions.get(varIndex), writeInsToVarsMap);
		}
	}
	
	/**
	 * generateWriteInsUsingModifiedFields:
	 * 	Set<String> HashMap<String, ArrayList<Integer>> -> none
	 * given a set of qualified field names (such as heap.Example01.e1.a) and
	 * a map of field names to instruction position lists, this method will
	 * go through the qualified field names, which are presumed to be affected
	 * fields, will find the write instructions that are reachably affected by
	 * these. For each field name, we will map it to the list of write
	 * instructions that it affects. The invoking class should make sure to
	 * have access to the map which will contain the resulting information.
	 * 
	 * @param fieldNames
	 * 			the list of qualified field names that are considered affected
	 * @param fieldsToWriteInsMap
	 * 			the mapping of field names to lists of impacted write positions
	 */
	public void generateWriteInsUsingModifiedFields(Set<String> fieldNames,
			HashMap<String, ArrayList<Integer>> fieldsToWriteInsMap) {
		
		for(String fieldName : fieldNames) {
			
			
		}
	}


	/**
	 * exploreWriteInsn:
	 * 	String Integer HashMap<String, ArrayList<Integer>> -> void
	 * 
	 * 
	 * @param varName
	 * @param varPos
	 * @param writeInsToVarsMap
	 */
	private void exploreWriteInsn(String varName, Integer varPos,
							HashMap<String, ArrayList<Integer>> writeInsToVarsMap) {
		if(exploredVarNames.contains(varName)) return;
		exploredVarNames.add(varName);

		if(exploredVarPoses.contains(varPos)) return;
		exploredVarPoses.add(varPos);


		Iterator<Integer> posItr = opToVarNames.
									keySet().iterator();
		while(posItr.hasNext()) {
			Integer pos = posItr.next();
			ArrayList<String> varNames = opToVarNames.get(pos);
			if(varNames.contains(varName)) {

				assert (insContext.containsKey(pos));
				InstructionContext ic = insContext.get(pos);

				Instruction insn = ic.getInstruction().getInstruction();
				String variableN = getWriteVariableName(insn, ic);
				if(variableN != null) {
					if(isReachable(varPos, ic.getInstruction().getPosition())) {
						addWriteInsVarToInsnPositions(variableN, ic,
								writeInsToVarsMap);
						exploreWriteInsn(variableN, ic.getInstruction().getPosition(),
								writeInsToVarsMap);
					}
				} else {
					 exploreWriteInsn(pos, writeInsToVarsMap);
				}

			}
		}
	}

	/**
	 * exploreWriteInsn: Integer HashMap<String, ArrayList<Integer>> -> void
	 * 
	 * 
	 * @param pos
	 * @param writeInsToVarsMap
	 */
	private void exploreWriteInsn(Integer pos,
						HashMap<String, ArrayList<Integer>> writeInsToVarsMap) {
		if(exploredVarPoses.contains(pos)) return;
			exploredVarPoses.add(pos); // move to next line and remove indent
			// in order to reduce confusion about how this works.

		Iterator<Integer> opOtherItr = opToOtherOp.keySet().iterator();
		while(opOtherItr.hasNext()) {

			Integer opOther = opOtherItr.next();
			ArrayList<Integer> opOtherVals = opToOtherOp.get(opOther);
			if(opOtherVals.contains(pos)) {
				assert (insContext.containsKey(opOther));
				InstructionContext ic = insContext.get(opOther);
				Instruction insn = ic.getInstruction().getInstruction();
				String variableN = getWriteVariableName(insn, ic);
				if(variableN != null) {
					addWriteInsVarToInsnPositions(variableN, ic,
							writeInsToVarsMap);
					exploreWriteInsn(variableN, opOther, writeInsToVarsMap);
				} else {
					exploreWriteInsn(opOther, writeInsToVarsMap);
				}

			}
		}
	}


	/**
	 *
	 * @param conditionalBr a set of bytecode positions
	 */
	public HashMap<String, ArrayList<Integer>> genWriteInsCDOnBranches
											(Set<Integer> conditionalBr,
													boolean genTransitiveControlBr) {
		HashMap<String, ArrayList<Integer>> writeInsToVarsMap = new
									HashMap<String, ArrayList<Integer>>();

		if(!genTransitiveControlBr) return writeInsToVarsMap;

		Iterator<Integer> condItr = conditionalBr.iterator();

		while(condItr.hasNext()) {
			Integer condPos = condItr.next();
			//System.out.println(condPos + " ln:" + mg.getLineNumberTable(
			//						mg.getConstantPool()).getSourceLine(condPos));
			//System.out.println(branchToDependentWriteInsMap.get(condPos) + " -----");

			if(!branchToDependentWriteInsMap.containsKey(condPos)) continue;

			ArrayList<Integer> writePos = branchToDependentWriteInsMap.get(condPos);
			findWriteInstructions(writePos, writeInsToVarsMap);

			ArrayList<Integer> secondaryPos = branchToDependentSecondaryInsMap.
															get(condPos);
			for(int sIndex = 0; sIndex < secondaryPos.size(); sIndex++) {
				Integer sPos = secondaryPos.get(sIndex);
				if(readVarPosToWriteVarPosMap.containsKey(sPos)) {
					ArrayList<Integer> writeInsns =
									readVarPosToWriteVarPosMap.get(sPos);
					findWriteInstructions(writeInsns, writeInsToVarsMap);
				}
			}
		}
		computeTransitiveClosureOnWriteIns(writeInsToVarsMap, new HashSet<String>());
		//System.out.println(writeInsToVarsMap.toString());

		return writeInsToVarsMap;
	}


	private void findWriteInstructions(ArrayList<Integer> writePos,
					HashMap<String, ArrayList<Integer>> writeInsToVarsMap) {

		for(int dIndex = 0; dIndex < writePos.size(); dIndex++) {
			Integer dPos = writePos.get(dIndex);
			assert (insContext.containsKey(dPos));
			InstructionContext ic = insContext.get(dPos);
			Instruction insn = ic.getInstruction().getInstruction();
			String varName = getWriteVariableName(insn, ic);

			if(varName != null) {
				addWriteInsVarToInsnPositions(varName, ic,
											writeInsToVarsMap);
			}
		}
	}

	//get the list of variables that "use" the variables in the set of
	//writeVars
	protected void computeTransitiveClosureOnWriteIns(HashMap<String,
											ArrayList<Integer>> writeVars,
											Set<String> visitedW) {
		Set<String> writeVariables = new HashSet<String>();
		Iterator<String> wItr = writeVars.keySet().iterator();
		while(wItr.hasNext()) {
			String wVar = wItr.next();
			if(!visitedW.contains(wVar)) {
				writeVariables.add(wVar);
				visitedW.add(wVar);
			}
		}
		wItr = writeVariables.iterator();
		while(wItr.hasNext()) {
			String wVar = wItr.next();
			HashMap<String, ArrayList<Integer>> otherWriteVars =
							new HashMap<String, ArrayList<Integer>>();
			checkVarDependence(wVar, writeVariables,
								otherWriteVars);
			writeVars.putAll(otherWriteVars);
			computeTransitiveClosureOnWriteIns(otherWriteVars, visitedW);

		}

	}

	private void checkVarDependence (String writeVar,
		Set<String> visitedWrites, HashMap<String, ArrayList<Integer>> writeVars) {

		//get the other vars using writeVar
		Iterator<Integer> opItr = this.opToVarNames.keySet().iterator();
		while(opItr.hasNext()) {
			Integer opPos = opItr.next();
			ArrayList<String> vars = opToVarNames.get(opPos);
			if(vars.contains(writeVar)) {
				InstructionContext ic = insContext.get(opPos);
				Instruction insn = ic.getInstruction().getInstruction();
				String theVar = getWriteVariableName(insn, ic);
				if(theVar == null) {
					checkOps(opPos, writeVars, new HashSet<Integer>());
				}
			}
		}
	}

	private void checkOps(Integer varOp,
						HashMap<String, ArrayList<Integer>> writeVars,
						Set<Integer> visitedOps) {
		Iterator<Integer> opItr = this.opToOtherOp.keySet().iterator();
		if(visitedOps.contains(varOp)) return;
		visitedOps.add(varOp);
		while(opItr.hasNext()) {
			Integer opPos = opItr.next();
			ArrayList<Integer> otherOps = opToOtherOp.get(opPos);
			if(otherOps.contains(varOp)) {
				InstructionContext ic = insContext.get(opPos);
				Instruction insn = ic.getInstruction().getInstruction();
				String theVar = getWriteVariableName(insn, ic);
				//System.out.println("theVar is again :" + theVar.toString());
				if(theVar == null) {
					checkOps(opPos, writeVars, visitedOps);
				} else {
					ArrayList<Integer> writePos;
					if(writeVars.containsKey(theVar)) {
						writePos = writeVars.get(theVar);
					} else{
						writePos = new ArrayList<Integer>();
					}
					writePos.add(opPos);
					writeVars.put(theVar, writePos);
				}
			}
		}
	}

	public String getWriteVariable(Integer position) {
		InstructionContext ic = absMethodInfo.
					getInstructionContexts().get(position);
		Instruction insn = ic.getInstruction().getInstruction();
		return getWriteVariableName(insn, ic);
	}

	protected String getWriteVariableName(Instruction insn, InstructionContext ic) {

		if(!isWriteInstruction(insn)) return null;
		/*
		 * For these first two instruction types, instead of looping
		 * through the LocalVariable array, can we simply check if
		 * val is a valid position in the array and then getName for
		 * that LocalVariable? This would be more efficient.
		 */
		if(insn instanceof StoreInstruction) {
			return getLocalVariableName(
						((StoreInstruction) insn).getIndex());
		} else if (insn instanceof IINC) {
			return getLocalVariableName(((IINC) insn).getIndex());
		} else if (insn instanceof AASTORE || insn instanceof BASTORE
				|| insn instanceof CASTORE || insn instanceof DASTORE
				|| insn instanceof FASTORE || insn instanceof IASTORE
				|| insn instanceof LASTORE || insn instanceof SASTORE) {
			return getArrayStoreInstruction(insn, ic);
		}
		else if (insn instanceof PUTFIELD ) {
			//Checking the name of the fields in case of dynamic instance?
			PUTFIELD putfield = (PUTFIELD) insn;
			String fieldName = putfield.getFieldName(mg.getConstantPool());
			String fullName = getFieldReferenceString(ic, true);
			//String fieldtype = putfield.getFieldType(mg.getConstantPool()).toString();
			return fullName.concat("."+fieldName);
		} else if (insn instanceof PUTSTATIC) {
			PUTSTATIC putstatic = (PUTSTATIC) insn;
			String fullName = getFieldReferenceString(ic, true);
			String fieldName = putstatic.getFieldName(mg.getConstantPool());
			//String fieldtype = putstatic.getFieldType(mg.getConstantPool()).toString();
			return fullName.concat("."+fieldName);
		}
		return null;
	}

	private String getArrayStoreInstruction(Instruction insn, InstructionContext ic) {
		HashMap<Integer, InstructionNode> controlPathAnalysis =
			absMethodInfo.getControlPathAnalysisInfo();
		HashMap<Integer, ArrayList<Integer>> allPreds =
			absMethodInfo.getPredecessors();
		Integer pos = ic.getInstruction().getPosition();
		int toPop = ic.getInstruction().getInstruction().
									consumeStack(mg.getConstantPool());
		ArrayList<Integer> preds = allPreds.get(pos);
		String fullName = "";
		String index = "";
		if(preds.size() == 0) return fullName;
		int predPosition = preds.get(0);
		InstructionNode predIn = controlPathAnalysis.get(predPosition);
		ArrayList<VariableInfo> sf =
							predIn.getNodeInfo().getStackFrame();
		int startIndex = sf.size() - 1;
		int counter = 0;
		//Stack: ..., arrayref, index, value -> ...
		for(int varIndex = startIndex;
				(varIndex >=0 && varIndex > (startIndex - toPop));
				varIndex--) {
			VariableInfo vi = sf.get(varIndex);
			if (counter == 1) {
				// the index into the array
				index = index.concat("["+vi.getVariableName().toString()+"]");
			}
			else if (counter == 2) {
				fullName = fullName.concat(vi.getVariableName().toString());
			}
			counter++;
		}
		//fullName =  fullName.concat(index);
		if(!fullName.equals(""))return fullName;
		return null;
	}

	private String getLocalVariableName(int val) {
		LocalVariableTable table = mg.getLocalVariableTable(mg.getConstantPool());
		LocalVariable[] lv = table.getLocalVariableTable();
		for(int lIndex = 0; lIndex < lv.length; lIndex++) {
			if(lv[lIndex].getIndex() == val /**  &&
					lv[lIndex].getStartPC() <= ic.getInstruction().
													  getPosition()**/)  {
				return lv[lIndex].getName();
			}
		}
		return null;
	}

	protected String getFieldReferenceString(InstructionContext ic, boolean isPutOp) {
		HashMap<Integer, InstructionNode> controlPathAnalysis =
							absMethodInfo.getControlPathAnalysisInfo();
		HashMap<Integer, ArrayList<Integer>> allPreds =
							absMethodInfo.getPredecessors();
		Integer pos = ic.getInstruction().getPosition();
		int toPop = ic.getInstruction().getInstruction().
									consumeStack(mg.getConstantPool());
		ArrayList<Integer> preds = allPreds.get(pos);
		String fullName = "";
		if(preds == null || preds.size() == 0) return fullName;
		int predPosition = preds.get(0);
		InstructionNode predIn = controlPathAnalysis.get(predPosition);
		ArrayList<VariableInfo> sf =
							predIn.getNodeInfo().getStackFrame();
		int startIndex = sf.size() - 1;
		//Stack: ..., objectref, value -> ...
		for(int varIndex = startIndex;
				(varIndex >=0 && varIndex > (startIndex - toPop));
				varIndex--) {
			if(varIndex == startIndex && isPutOp) continue;
			//After skipping the value in the stack to the objectref
			// if there is a put operation otherwise get to it
			//Stack: ..., objectref
			VariableInfo vi = sf.get(varIndex);
			//fullName = fullName.concat("."+vi.getVariableName().toString());
			if(fullName != "")
				fullName = fullName.concat("."+vi.getVariableType().toString());
			else 
				fullName = fullName.concat(vi.getVariableType().toString());
			
			/**int objsize = vi.getObjSize();
			for(int objIndex = 0; objIndex < objsize; objIndex++) {
				//fullName = fullName.concat("." + vi.
				//						getVariableNameAtIndex(objIndex));
				fullName = fullName.concat("."+vi.getVariableTypeAtIndex(objIndex));
			}**/
		}
		return fullName;
	}

	/**
	 * addWriteInsVarToInsnPositions:
	 * 	String InstructionContext HashMap<String, ArrayList<Integer>> -> void
	 * this is a generic method that, given a String that is a variable name,
	 * an InstructionContext for the instruction of interest, and a Map of
	 * variable names to the list of instruction positions that they are
	 * associated with, will map the given variable name to the position of
	 * the given instruction context in the given map.
	 * 
	 * @param varName
	 * 			the name of the variable being mapped
	 * @param ic
	 * 			the InstructionContext of the instruction being mapped
	 * @param writeInsToVarsMap
	 * 			the map that is used for mapping these things together
	 */
	private void addWriteInsVarToInsnPositions(String varName,
			InstructionContext ic, HashMap<String, ArrayList<Integer>>
														writeInsToVarsMap) {
		ArrayList<Integer> positions;
		if(!writeInsToVarsMap.containsKey(varName)) {
			positions = new ArrayList<Integer>();
		} else {
			positions = writeInsToVarsMap.get(varName);

		}
		if(!positions.contains(ic.getInstruction().getPosition())) {
			positions.add(ic.getInstruction().getPosition());
		}
		writeInsToVarsMap.put(varName, positions);
	}
	/**
	 * 通过checkreachability方法部分应用了规则4（比较使用了某变量的Write和Cond之间的可达性）
	 * 返回的集合中，只保留了到writePostions能reachable的那些cPositions
	 * @param writeVarsIns
	 * @param flag 
	 * @return
	 */
	public Set<Integer> getCondBranchesWithVars(HashMap<String,
									ArrayList<Integer>> writeVarsIns, String flag) {
		Set<Integer> condPositions = new HashSet<Integer>();
		Iterator<String> wtrItr = writeVarsIns.keySet().iterator();
		while(wtrItr.hasNext()) {
			String writeVar = wtrItr.next();
			Set<Integer> writePositions = new HashSet<Integer>();
			writePositions.addAll(writeVarsIns.get(writeVar));

			if(varNameToCondBranchPosMap.containsKey(writeVar)) {
				Set<Integer> cPositions = new HashSet<Integer>();
				cPositions.addAll(varNameToCondBranchPosMap.get(writeVar));
				//updates cPositions
				//更新后，只留下到writePostions能reachable的那些cPositions
				checkReachability(writePositions, cPositions, true, flag);
				condPositions.addAll(cPositions);
			}
		}
		return condPositions;
	}


	public Set<Integer> getCondBranchesWithVars(ArrayList<String> vars) {
		Set<Integer> condPositions = new HashSet<Integer>();
		for(int varIndex = 0; varIndex < vars.size(); varIndex++) {
			if(varNameToCondBranchPosMap.containsKey(vars.get(varIndex))) {
				ArrayList<Integer> tmp = varNameToCondBranchPosMap.
													get(vars.get(varIndex));
				condPositions.addAll(tmp);
			}
		}
		return condPositions;
	}

	public Set<Integer> getAllCondBranchesUsingVar(String var) {
		Set<Integer> condPositions = new HashSet<Integer>();

		if(varNameToCondBranchPosMap.containsKey(var)){
			condPositions.addAll(varNameToCondBranchPosMap.get(var));
		}
		return condPositions;
	}


	public void updateGlobalTrackCond() {
		this.globalTrackCond.addAll(this.trackCond);
	}

	public void checkGlobalTrackCond(Set<Integer> condPositions) {
		condPositions.removeAll(globalTrackCond);
		trackCond.clear();
		trackCond.addAll(condPositions);
	}

	public Set<Integer> getTrackedBranches() {
		return trackCond;
	}

	public void clearTrackedCondAndUpdateGlobal() {
		this.globalTrackCond.addAll(trackCond);
		trackCond.clear();
	}

	public void clearAllTrackedVariables() {
		this.globalTrackCond.clear();
		this.globalTrackWrite.clear();
		this.trackCond.clear();

	}

	public ArrayList<String> getRelevantVarNamesUsedInCondInsn (Set<Integer> condPositions) {
		//System.out.println(condPositions.toString() + "condPositions");
		ArrayList<String> varNames = new ArrayList<String>();
		Iterator<String> varItr = varNameToCondBranchPosMap.keySet().iterator();
		while(varItr.hasNext()) {
			String varN = varItr.next();
			Set<Integer> tmp = new HashSet<Integer>();
			tmp.addAll(condPositions);
			tmp.retainAll(varNameToCondBranchPosMap.get(varN));
			if(tmp.size() > 0) {
				varNames.add(varN);
			}
		}
		return varNames;
	}

	/**
	 * checkReachability: Set<Integer> Set<Integer> Boolean -> void
	 * given a Set of Integers that represent write positions and another set
	 * of Integers that represent conditional positions and a boolean dictating
	 * whether or not the conditional set should be updated, this method will
	 * iterate over both sets checking the reachability between every pair of
	 * write and cond. positions. If the write instruction has reachability to
	 * the conditional instruction, then the write position will be added to
	 * the set of globalTrackWrites (which is a set of impacted write nodes).
	 * 
	 * 
	 * I believe this check is done as part of the backward slicing (4th rule
	 * in original DiSE paper).
	 * 
	 * @param writePos
	 * 			the set of write positions to check
	 * @param condPos
	 * 			the set of conditional positions to check
	 * @param updateCond
	 * 			whether or not to update the given conditional set
	 */
	public void checkReachability(Set<Integer> writePos, Set<Integer> condPos,
													boolean updateCond, String flag) {
		Set<Integer> newConditionPos = null;
		if(updateCond) {
			newConditionPos = new HashSet<Integer>();
		}
		// for each cPos in condPos
		Iterator<Integer> cPosItr = condPos.iterator();
		while(cPosItr.hasNext()) {
			Integer cPos = cPosItr.next();
			Iterator<Integer> wPosItr = writePos.iterator();
			//for each wPos in WritePos
			while(wPosItr.hasNext()) {
				Integer wPos = wPosItr.next();
				if(isReachable(wPos, cPos)) {
					if(updateCond) {
						newConditionPos.add(cPos);
					}
					//这是set，不怕重复
					this.globalTrackWrite.add(wPos);
					//如果是wPos在cPos中被使用并可达,且cPos不在ACN中、wPos在AWN中
					//cPos在之后会被添加到track中
					if (flag.contains("modified")) {
						if (!depend.containsKey(wPos)) {
							Dependency dependency = new Data(wPos, -1);
							Set<Dependency> dependencies = new HashSet<>();
							dependencies.add(dependency);
							depend.put(wPos, dependencies);
						}
						if (!depend.containsKey(cPos) && depend.containsKey(wPos)) {
							Dependency dependency = new Data(cPos, wPos);
							Set<Dependency> dependencies = new HashSet<>();
							dependencies.add(dependency);
							depend.put(cPos, dependencies);
						}
						else if (depend.containsKey(cPos) && depend.containsKey(wPos)){
							Dependency dependency = new Data(cPos, wPos);
							depend.get(cPos).add(dependency);
						}						
					}
					else {
						//如果是wPos在cPos中被使用并可达,且cPos在ACN中、wPos不在AWN中
						//此时wPos被添加到track中
						if (!depend.containsKey(wPos) && depend.containsKey(cPos)) {
							Dependency dependency = new Data(wPos, cPos);
							Set<Dependency> dependencies = new HashSet<>();
							dependencies.add(dependency);
							depend.put(wPos, dependencies);
						}
						else if (depend.containsKey(wPos) && depend.containsKey(cPos)){
							Dependency dependency = new Data(wPos, cPos);
							depend.get(wPos).add(dependency);
						}
					}
				}
			}

		}
		//若更新，则只保留到writePos能够reachable的那些conditionPos
		if(updateCond) {
			condPos.retainAll(newConditionPos);
		}
	}

	/**
	 * checkReachability: ArrayList<Integer> Set<Integer> boolean -> void
	 * given an ArrayList of Integers that represent write positions, this
	 * method will convert it to a set and then using the other two
	 * parameters as is, it will call the original checkReachability.
	 * 
	 * @param writePos
	 * 			an ArrayList of write positions to check
	 * @param condPos
	 * 			a Set of conditional positions to check
	 * @param updateCond
	 * 			whether or not to update the given conditional set
	 */
	public void checkReachability(ArrayList<Integer> writePos, Set<Integer> condPos,
											boolean updateCond, String flag) {
		Set<Integer> tmpWritePos = new HashSet<Integer>();
		tmpWritePos.addAll(writePos);
		checkReachability(tmpWritePos, condPos, updateCond, flag);
	}

	/**
	 * isReachable: Integer Integer -> boolean
	 * given an Integer which is an instruction and another Integer value
	 * which is another instruction, this method will check for reachability
	 * either based on the instructions being in the same basic block or based
	 * on reachability between their respective basic blocks.
	 * Note: This checks for reachability from first to second, not the other
	 * way around.
	 * 
	 * @param first
	 * 			the position of the first bytecode instruction
	 * @param second
	 * 			the position of the second bytecode instruction
	 * @return boolean
	 * 			whether or not there is reachability from first to second
	 */
	protected boolean isReachable(Integer first, Integer second) {
		int firstOffset = cfg.getStartOffset(first.intValue());
		int secondOffset = cfg.getStartOffset(second.intValue());

		// if they are part of the same basic block and first comes first,
		// then it has reachability to second, so return true.
		if(firstOffset == secondOffset) { // its in the same block
			if(first <= second ||
					(scc.allSCC.contains(firstOffset))) return true;
			else return false;
		}
		
		// not in the same basic block, so check the distance matrix for a
		// value and then see if that value is less than MAX_VALUE, meaning
		// that there is reachability.
		int reachable = cfg.getDistanceMatrix().getValue
									(cfg.getIndexOfPosition(firstOffset),
									cfg.getIndexOfPosition(secondOffset));
		if(reachable < Integer.MAX_VALUE) {
			return true;
		}
		return false;
	}


	public void generateFinalMapBetweenVarsAndCond(ArrayList<String> varNames) {
		ArrayList<String> newVars = new ArrayList<String>();
		for(int varIndex = 0; varIndex < varNames.size(); varIndex++) {
			String varName = varNames.get(varIndex);
			if (!varNamesToWriteIns.containsKey(varName)) continue;
			ArrayList<Integer> writePos = varNamesToWriteIns.get(varName);
			checkReachability(writePos, globalTrackCond, false, "check write");

			for(int wIndex = 0; wIndex < writePos.size(); wIndex++) {
				Integer wPos = writePos.get(wIndex);
				ArrayList<String> varNamesOther = getVarsUsedInWriteAndArthInsn(wPos);
				newVars.addAll(varNamesOther);
			}
		}
		newVars.removeAll(varNames);
		for(int varIndex = 0; varIndex < newVars.size(); varIndex++) {
			String varName = newVars.get(varIndex);
			if (!varNamesToWriteIns.containsKey(varName)) continue;
			ArrayList<Integer> writePos = varNamesToWriteIns.get(varName);
			checkReachability(writePos, globalTrackCond, false, "check write");
		}
		Iterator<Integer> brItr = branchToDependentWriteInsMap.
											keySet().iterator();
		while(brItr.hasNext()) {
			Integer bPos = brItr.next();
			ArrayList<Integer> writeDependent = new ArrayList<Integer>();
			writeDependent.addAll(branchToDependentWriteInsMap.get(bPos));
			writeDependent.retainAll(globalTrackWrite);
			if(!writeDependent.isEmpty()) {
				dependentTrack.add(bPos);
			}
		}
	}

	
	/**
	 * checkVariablesUsedInInstructions: ...
	 * this method generates the variables that are 'used' in an instruction
	 * such as a write instruction or an invoke instruction. This method will
	 * be invoked for Arithmetic, Write, Invoke, and Return instructions.
	 * 
	 * @param position
	 * @param ic
	 * @param insUsingVarNames
	 * @param insUsingComplex
	 * @param insUsingRetVals
	 */
	protected void checkVariablesUsedInInstructions(Integer position,
			InstructionContext ic, HashMap<Integer, ArrayList<String>> insUsingVarNames,
			HashMap<Integer, ArrayList<Integer>> insUsingComplex,
			HashMap<Integer, ArrayList<Integer>> insUsingRetVals) {
		HashMap<Integer, InstructionNode> controlPathAnalysis =
								absMethodInfo.getControlPathAnalysisInfo();
		HashMap<Integer, ArrayList<Integer>> allPreds =
								absMethodInfo.getPredecessors();
		Instruction insn = ic.getInstruction().getInstruction();

		if(insn instanceof IINC) {
			String varName = getLocalVariableName(((IINC) insn).getIndex());
			updateVarNameStructure(position, varName, insUsingVarNames);
			return;
		}

		int toPop = insn.consumeStack(mg.getConstantPool());
		if(!allPreds.containsKey(position)) return;
		ArrayList<Integer> preds = allPreds.get(position);

		for(int predIndex = 0; predIndex < preds.size(); predIndex++) {
			int predPosition = preds.get(predIndex);
			InstructionNode predIn = controlPathAnalysis.get(predPosition);
			//System.out.println(predIn.getNodeInfo().getStackFrame().toString() + " ---->");
			ArrayList<VariableInfo> stack = predIn.getNodeInfo().getStackFrame();
			int startIndex =stack.size() -1;
			for(int stackIndex = startIndex;
					(stackIndex >= 0 && stackIndex > (startIndex - toPop));
					stackIndex--) {
				if(stack.size() < stackIndex) return;

				VariableInfo vi = stack.get(stackIndex);
				if( vi.getVariableType().
						 toString().equals("__CONSTANT_VAL__")) {
					checkReadVariableDependence(vi, ic);
					continue;
				}
				String varName = vi.getVariableName().toString();
				Integer varPos = vi.getPositionOfVariable();
				if(varName.equals("__UNKNOWN__")) {
					ArrayList<Integer> otherPos;
					if(insUsingComplex.containsKey(position)) {
						otherPos = insUsingComplex.get(position);
					} else {
						otherPos = new ArrayList<Integer>();
					}
					otherPos.add(varPos);
					insUsingComplex.put(position, otherPos);
					// even if we don't step in the call sites; the instruction
					// following a call site will get marked with the return
					// element tag.
				} else if (varName.equals("RETURN_ELEMENT")) {
					ArrayList<Integer> otherPos;
					if(insUsingRetVals.containsKey(position)) {
						otherPos = insUsingRetVals.get(position);
					} else {
						otherPos = new ArrayList<Integer>();
					}
					otherPos.add(varPos);
					//System.out.println("pos: " + position + "-->" + "varPos: -->" + varPos);
					insUsingRetVals.put(position, otherPos);
				}
				else {
					//System.out.println("varName is:" + varName);
					InstructionContext varContext = insContext.get(varPos);
					Instruction varInsn = varContext.getInstruction().getInstruction();
					if(varInsn instanceof GETFIELD || varInsn instanceof GETSTATIC) {
//						String fullName = this.getFieldReferenceString(varContext, false);
//						varName = fullName.concat("."+varName);
						// this is the new way of constructing the variable
						// name for a field name.
						// TODO: Does this work for GETSTATIC? Check constructQualif...
						int varPosn = varContext.getInstruction().getPosition();
						varName = this.constructQualifiedFieldName(varPosn);
					}
					updateVarNameStructure(position, varName, insUsingVarNames);
				}
			}
		}
		//System.out.println("opToVarNames: " + opToVarNames.toString());
		//System.out.println("opToOtherOps: " + this.opToOtherOp.toString());
	}
	
	
	/**
	 * updateVarNameStructure:
	 * 	Integer String HashMap<Integer, ArrayList<String>> -> void
	 * given a Integer that represents the position of an instruction,
	 * a String that represents the name of a variable, and a HashMap for
	 * mapping positions to the list of variable names used in the instruction,
	 * this method will simply add the mapping between the given position and
	 * variable name. The given HashMap will be updated and this will be
	 * available to the invoker.
	 * 
	 * @param position
	 * @param varName
	 * @param insUsingVarNames
	 */
	private void updateVarNameStructure(Integer position, String varName,
			HashMap<Integer, ArrayList<String>> insUsingVarNames) {
		ArrayList<String> variableNames;
		if(insUsingVarNames.containsKey(position)){
			variableNames = insUsingVarNames.get(position);
		} else {
			variableNames = new ArrayList<String>();
		}
		variableNames.add(varName);
		insUsingVarNames.put(position, variableNames);
	}

	public void checkReadVariableDependence(VariableInfo vi,
										InstructionContext writeContext) {
		Integer wPos = writeContext.getInstruction().getPosition();
		Integer vPos = vi.getPositionOfVariable();
		// check whether vPos is control dependent on a branch pos b_1 such
		// that wPos is not control dependent on b_1
		ArrayList<Integer> writePositions;
		if(readVarPosToWriteVarPosMap.containsKey(vPos)) {
			writePositions = readVarPosToWriteVarPosMap.get(vPos);
		} else {
			writePositions = new ArrayList<Integer>();
		}
		writePositions.add(wPos);
		readVarPosToWriteVarPosMap.put(vPos, writePositions);

	}

    protected boolean isArithmethicOrCompareInstruction(Instruction insn) {
    	if(insn instanceof ArithmeticInstruction ||
				insn instanceof DCMPG || insn instanceof DCMPL ||
				insn instanceof FCMPG || insn instanceof FCMPL ||
				insn instanceof LCMP) {
    		return true;
    	}
    	return false;
    }

    /**
     * analyzeArithmeticAndWriteOperations: none -> void
     * this method goes through all the instructions in the method and for
     * those that are either 1) Arithmetic/Comparison instructions or
     * 2) Write instructions,
     */
	public void analyzeArithmeticAndWriteOperations() {
		//System.out.println("analyzeArithmetic and write operations");
		HashMap<Integer, InstructionContext> inContext = absMethodInfo.
													getInstructionContexts();
		Iterator<Integer> contextItr = inContext.keySet().iterator();

		while(contextItr.hasNext()) {
			Integer position = contextItr.next();
			InstructionContext ic = inContext.get(position);
			Instruction insn = ic.getInstruction().getInstruction();
			if(isArithmethicOrCompareInstruction(insn)) {
				checkVariablesUsedInInstructions(position, ic, opToVarNames, opToOtherOp,
						opToRetValOfCallSites);
			} else {
				String writeVarName = getWriteVariableName(insn, ic);
				if(writeVarName == null) continue; //its not a write insn
				checkVariablesUsedInInstructions(position, ic, opToVarNames, opToOtherOp,
						opToRetValOfCallSites);

				ArrayList<Integer> writePositions;
				if(varNamesToWriteIns.containsKey(writeVarName)) {
					writePositions = varNamesToWriteIns.get(writeVarName);
				} else {
					writePositions = new ArrayList<Integer>();
				}
				writePositions.add(position);
				varNamesToWriteIns.put(writeVarName, writePositions);
				//System.out.println("varNamesToWriteIns :" + varNamesToWriteIns.toString());
			}
		}
	}

	public Set<Integer> checkModifiedWriteStatement(Set<Integer> modifiedIns,
							Set<Integer> visitedWPos) {
		Set<Integer> reachableWriteLocs = new HashSet<Integer>();
		Set<String> visitedW = new HashSet<String>();
		HashMap<Integer, InstructionContext> inContext = absMethodInfo.
		getInstructionContexts();
		Iterator<Integer> modItr = modifiedIns.iterator();
		while(modItr.hasNext()) {
			Integer pos = modItr.next();
			InstructionContext ic = inContext.get(pos);
			//如果得到的context为空
			if (ic == null) {
				continue;
			}
			String writeVarName = getWriteVariableName(ic.getInstruction().
					getInstruction(), ic);
			if(writeVarName == null) continue; //its not a write insn

			// get write of all variables that it is reading
			HashMap<String, ArrayList<Integer>> writeVars =
							new HashMap<String, ArrayList<Integer>>();
			checkVarDependence(writeVarName, visitedW,
												writeVars);
			Iterator<String> wItr = writeVars.keySet().iterator();
			while(wItr.hasNext()) {
				String wName = wItr.next();
				ArrayList<Integer> wPos = writeVars.get(wName);
				Set<Integer> toExplore = new HashSet<Integer>();
				for(int wIndex = 0; wIndex < wPos.size(); wIndex++) {
					if(!visitedWPos.contains(wPos.get(wIndex))) {
						toExplore.add(wPos.get(wIndex));
					}
				}
				visitedWPos.addAll(toExplore);
				checkModifiedWriteStatement(toExplore, visitedWPos);
			}

			if(varNameToCondBranchPosMap.containsKey
					(writeVarName)) {
				ArrayList<Integer> condPos = varNameToCondBranchPosMap
													.get(writeVarName);
				for(int condIndex = 0; condIndex < condPos.size(); condIndex++) {
					int wPosOffset = cfg.getStartOffset(pos);
					int cPosOffset = cfg.getStartOffset(condPos.get(condIndex));
					//如果用到该var的cond到该modifiedIns可达，添加到trackCond中
					if(cfg.getDistanceMatrix().getValue
							(cfg.getIndexOfPosition(wPosOffset),
							cfg.getIndexOfPosition(cPosOffset)) < Integer.MAX_VALUE) {
						trackCond.add(condPos.get(condIndex));
						//追踪依赖关系
						if (!depend.containsKey(condPos.get(condIndex))) {
							Dependency dependency = new Data(condPos.get(condIndex), pos);
							Set<Dependency> dependencies = new HashSet<>();
							dependencies.add(dependency);
							depend.put(condPos.get(condIndex), dependencies);							
						}
						else {
							Dependency dependency = new Data(condPos.get(condIndex), pos);
							depend.get(condPos.get(condIndex)).add(dependency);
						}
					}

				}
			}
			//添加初始追踪依赖关系，即Modified语句不依赖于任何语句
			if (!depend.containsKey(pos)) {
				Dependency dependency = new Dependency(pos, -1);
				Set<Dependency> dependencies = new HashSet<>();
				dependencies.add(dependency);
				depend.put(pos, dependencies);
			}
			reachableWriteLocs.add(pos);
		}
		return reachableWriteLocs;
	}

	public Set<Integer> markOtherConditionalBranches(Set<Integer> affectedWrite,
									boolean useAff) {
		Iterator<Integer> controlItr = this.branchToDependentWriteInsMap.
												keySet().iterator();
		Set<Integer> affectedCondPoses = new HashSet<Integer>();
		while(controlItr.hasNext()) {
			Integer controlPos = controlItr.next();
			ArrayList<Integer> wrtPoses = new ArrayList<Integer>();
			wrtPoses.addAll(branchToDependentWriteInsMap.get(controlPos));
			if(!useAff) {
				wrtPoses.retainAll(globalTrackWrite);
			} else {
				wrtPoses.retainAll(affectedWrite);
			}
			if(!wrtPoses.isEmpty()) {
				affectedCondPoses.add(controlPos);
			}
		}
		return affectedCondPoses;
	}


	public void updateToBeDroppedSet(Set<Integer> condPoses, Set<Integer> tobeDroppedSet,
			Set<Integer> affectedCondPoses) {
		if(tobeDroppedSet.size() <= 0) {
			tobeDroppedSet.addAll(condPoses);
			tobeDroppedSet.removeAll(affectedCondPoses);
		} else {
			Iterator<Integer> condItr = condPoses.iterator();
			while(condItr.hasNext()) {
				Integer condPos = condItr.next();
				if(affectedCondPoses.contains(condPos) &&
						tobeDroppedSet.contains(condPos)) continue;
				if(!affectedCondPoses.contains(condPos))
					tobeDroppedSet.add(condPos);
			}
		}
	}


}

//TODO: if there is variable resuse in different scopes the implementation will over-approximate
// need to define the scope of variables with the same name